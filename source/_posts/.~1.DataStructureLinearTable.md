---
title: 1.数据结构——线性表
date: 2021-05-23 01:11:27
tags: 书籍
categories: 数据结构
cover: /img/data-structure.png
---

![image-20210523212647422](/img/1-DataStructureLinearTable/image-20210523212647422.png)

**线性表：零个或多个数据元素的有限序列**

同时也是最常用也最简单的一种结构

# 线性表的定义

1. List---->零个或多个数据元素的**有限序列**
2. 线性表元素的个数n(n>=0)定义为线性表的长度，当n=0时，称之为空表
3. 在较为复杂的线性表中，一个数据元素可以由**若干个数据项**组成---->比如大学上课时的花名册，至少有个姓名和学号，姓名和学号就是数据项
4. **线性表里的数据元素得是相同类型的数据**

# 线性表的抽象数据类型

**抽象数据类型：Abstract Data Type（ADT）**

```text
ADT List

Operation
	InitList(*L)----初始化操作，建立一个空的线性表L
	ListEmpty(L)----若线性表为空，返回true，否则返回false
	ClearList(*L)----将线性表清空
	GetElem(L,i,*e)----将线性表L中的第i个位置元素值返回给e
	LocateElem(L,e)----在线性表L中查找与e值相等的元素，success---->返回该元素在表中的序号，failed---->返回0
	ListInsert(*L,i,e)----在线性表L中的第i个位置插入新元素e
	ListDelete(*L,i,*e)----删除线性表L中的第i个位置元素，并用e返回该值
	ListLength(L)----返回线性表L的元素个数
```

# 线性表的顺序存储结构

**线性表的顺序存储结构，指的是用一段地址连续的存储单元存储线性表的数据元素。**

我么通常可以用一维数组来实现顺序存储结构

## 顺序存储方式

1. **存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置**
2. **线性表的最大存储容量：数组长度MaxSize**
3. **线性表的当前长度：length**

## 数据长度与线性表长度区别

**数据长度即数组长度——存放线性表的存储空间的长度**

**线性表的长度：线性表中数据元素的个数**

在任意时刻，线性表的长度应该小于等于数组的长度。

存储器中的每个存储单元都有自己的编号，这个编号称为地址。

**线性表的第i个元素存储在下标为i-1的位置**

# 顺序存储结构的插入与删除

## 获得元素操作

```java
typedef int Status;
Status GetElem(SqList L,int i,ElemType *e)
{
	if(L.length==0 || i<1 || i>L.length)
		return ERROR;
  *e=L.data[i-1]
  return OK;
}
```

## 插入操作

**插入算法的思路：**

1. 如果插入位置不合理，抛出异常；
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
3. 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；
4. 将要插入元素填入位置i处；表长加1

```java
Status ListInsert(SqList *L,int i,ElemType e)
{
	int k;
  // 顺序线性表已满
	if (L->length==MAXSIZE)
		return ERROR;
  // 当i不在范围内
  if (i<1 || i>L->length+1)
  	return ERROR;
  // 若插入的数据位置不在表尾
  if (i<=L->length)
  {
    // 将要插入的位置后数据元素向后移动一位
  	for(k=L->length-1;k>=i-1;k--){
  		L->data[k+1]=L->data[k];
  	}
  }
  // 将新元素插入
  L->data[i-1]=e;
  L->length++;
  return OK;
}
```

## 删除操作

**删除算法的思路：**

1. 如果删除位置不合理，抛出异常；
2. 取出删除元素；
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
4. 表长减1

```java
Status ListDelete(Sqlist *L,int i,ElemType *e)
{
  int k;
  // 线性表为空
  if (L->length==0)
    return ERROR;
  // 删除位置不正确
  if (i<1 || i>L->length)
    return ERROR;
  *e=L->data[i-1];
  // 如果删除不是最后位置
  if(i<L->length)
  {
    // 将删除位置后继元素前移
    for(k=i;k<L->length;k++)
      L->data[k-1]=L->data[k];
  }
  L->length--;
  return OK;
}
```

## 线性表顺序存储结构的优缺点

存，读数据时，不管哪个位置，时间复杂度都是O(1)；

而插入或删除时，时间复杂度都是O(n)

这说明：**线性表的存储结构比较适合元素个数不太变化，而更多时存取数据的应用。**

# 线性表的链式存储结构

<u>所有元素都不考虑相邻位置，哪有空位就到哪里，只需要让元素知道它下一个元素的位置在哪里就可以了，这样，所有的元素我们都可以通过遍历而找到。</u>

为了表示每个数据元素a[i]与其直接后继数据元素a[i+1]之间的逻辑关系，对数据元素a[i]来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置)，我们把**存储数据元素信息的域称为数据域**，把**存储直接后继位置的域称为指针域**。**指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点（Node）**

![img](/img/1-DataStructureLinearTable/webp)

![image-20210525120449386](/img/1-DataStructureLinearTable/image-20210525120449386-1915492.png)

# 单链表的读取

**获得链表第i个数据的算法思路：**

1. 声明一个结点p指向链表第一个结点，初始化j从1开始
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，i累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，返回结点p的数据

```java
Status GetElem(Linklist L,int i,ElemType *e)
{
  int j;
  // 声明结点p
  LinkList p;
  // 让p指向链表L的第一个结点
  p = L->next;
  // j为计数器
  j=1;
  // p不为空或者计数器j还没有等于i时，循环继续
  while (p&&j<1){
    // p指向下一个结点
    p=p->next;
    ++j;
  }
  if(!p || j>i)
    // 第i个元素不存在
    return ERROR;
  // 取第i个元素的数据
  *e = p->data;
  return OK;
}
```

**核心思想是：工作指针后移**

# 单链表的插入与删除

![image-20210525235117148](./img/1.DataStructureLinearTable/image-20210525235117148.png)
